<%graphql
  # Connection types are similar to ActiveRecord associations. Connections
  # always expose "edges" and "pageInfo". "edges" are the items in the
  # collection and "pageInfo" is pagination related metadata.
  fragment BrandConnection on BrandConnection {
    # edges returns an Array, however it doesn't return an Array of
    # Brands. Instead its a BrandEdge that has a node that is a
    # Brand. Sorry, for all the indirection.
    edges {
      # node is the Brand itself
      node {
        ...Views::Brands::ListItem::Brand
      }

      # Cursor is an opaque identifier that lets you fetch items before or
      # after this brand in this collection. To fetch the next 10 items,
      # we'll want the last item's cursor.
      cursor
    }

    # Pagination related metadata
    pageInfo {
      hasNextPage
      # hasPreviousPage can also be checked
    }
  }
%>
<% brands = Views::Brands::Brands::BrandConnection.new(brands) %>

<%#
  We could enumerate this list by brands.edges.each { |edge| edge.node }
  but each_node provides a handy enumerator to get each brand.
%>
<% brands.each_node do |brand| %>
  <%= render "brands/list_item", brand: brand %>
<% end %>

<% if brands.page_info.has_next_page? %>
  <li class="list-group-item show-more">
    <a class="js-load-more" href="<%= more_brands_path(after: brands.edges.last.cursor) %>">
      Show more brands...
    </a>
    <span class="octicon octicon-sync spinner"></span>
  </li>
<% end %>
